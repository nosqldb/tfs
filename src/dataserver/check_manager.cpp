/*
 * (C) 2007-2010 Alibaba Group Holding Limited.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *
 * Authors:
 *   linqing <linqing.zyd@taobao.com>
 *      - initial release
 *
 *
 */

#include "common/base_packet.h"
#include "message/message_factory.h"
#include "dataservice.h"
#include "check_manager.h"

namespace tfs
{
  namespace dataserver
  {
    using namespace tbutil;
    using namespace common;
    using namespace message;
    using namespace std;

    CheckManager::CheckManager(DataService& service):
      service_(service)
    {
    }

    CheckManager::~CheckManager()
    {
    }

    inline BlockManager& CheckManager::get_block_manager()
    {
      return service_.get_block_manager();
    }

    inline DataHelper& CheckManager::get_data_helper()
    {
      return service_.get_data_helper();
    }

    int CheckManager::get_sync_mirror(const uint64_t ns_ip, SyncBase*& base)
    {
      int ret = EXIT_PARAMETER_ERROR;
      std::vector<SyncBase*>& mirrors = service_.get_sync_mirror();
      std::vector<SyncBase*>::iterator iter = mirrors.begin();
      for ( ; iter != mirrors.end(); iter++)
      {
        if (Func::get_host_ip((*iter)->get_dest_addr().c_str()) == ns_ip)
        {
          base = *iter;
          ret = TFS_SUCCESS;
          break;
        }
      }
      return ret;
    }

    void CheckManager::run_check()
    {
      const int32_t SLEEP_TIME_S = 1;
      DsRuntimeGlobalInformation& ds_info = DsRuntimeGlobalInformation::instance();
      while (!ds_info.is_destroyed())
      {
        mutex_.lock();
        if (!pending_.empty())
        {
          CheckParam* param = pending_.front();
          pending_.pop();
          mutex_.unlock();
          do_check(*param);
          tbsys::gDelete(param);
        }
        else
        {
          mutex_.unlock();
          interruptable_usleep(SLEEP_TIME_S * 1000000);
        }
      }
    }

    int CheckManager::handle(tbnet::Packet* packet)
    {
      int ret = TFS_SUCCESS;
      int pcode = packet->getPCode();
      switch(pcode)
      {
        case REQ_CHECK_BLOCK_MESSAGE:
          ret = get_check_blocks(dynamic_cast<CheckBlockRequestMessage*>(packet));
          break;
        case REPORT_CHECK_BLOCK_MESSAGE:
          ret = add_check_blocks(dynamic_cast<ReportCheckBlockMessage*>(packet));
          break;
        default:
          ret = TFS_ERROR;
          TBSYS_LOG(WARN, "unknown pcode : %d",  pcode);
          break;
      }
      return ret;
    }

    int CheckManager::get_check_blocks(CheckBlockRequestMessage* message)
    {
      const TimeRange& range = message->get_time_range();
      const int32_t group_count = message->get_group_count();
      const int32_t group_seq = message->get_group_seq();
      CheckBlockResponseMessage* reply = new (std::nothrow) CheckBlockResponseMessage();
      assert(NULL != reply);
      int ret = get_block_manager().get_blocks_in_time_range(range,
          reply->get_blocks(), group_count, group_seq);
      if (TFS_SUCCESS == ret)
      {
        message->reply(reply);
      }
      else
      {
        tbsys::gDelete(reply);
        TBSYS_LOG(WARN, "get check blocks fail. ret: %d", ret);
      }
      return ret;
    }

    int CheckManager::add_check_blocks(ReportCheckBlockMessage* message)
    {
      int ret = TFS_SUCCESS;
      Mutex::Lock lock(mutex_);
      if (pending_.size() >= static_cast<uint32_t>(MAX_CHECK_QUEUE_SIZE))
      {
        ret = EXIT_CHECK_QUEUE_FULL;
      }

      if (TFS_SUCCESS == ret)
      {
        CheckParam* param =  new (std::nothrow) CheckParam();
        assert(NULL != param);
        *param = message->get_param();
        pending_.push(param);
        ret = message->reply(new StatusMessage(STATUS_MESSAGE_OK));
      }

      return ret;
    }

    void CheckManager::do_check(const CheckParam& param)
    {
      DsRuntimeGlobalInformation& info = DsRuntimeGlobalInformation::instance();
      create_msg_ref(ReportCheckBlockResponseMessage, rsp_msg);
      rsp_msg.set_seqno(param.seqno_);
      rsp_msg.set_server_id(info.information_.id_);
      check_block(param, rsp_msg.get_result());

      TBSYS_LOG(INFO, "report check status to %s, senqo: %" PRI64_PREFIX "d",
          tbsys::CNetUtil::addrToString(param.cs_id_).c_str(), param.seqno_);

      post_msg_to_server(param.cs_id_, &rsp_msg, Task::ds_task_callback);
    }

    void CheckManager::check_block(const CheckParam& param, vector<CheckResult>& result)
    {
      DsRuntimeGlobalInformation& ds_info = DsRuntimeGlobalInformation::instance();
      vector<uint64_t>::const_iterator iter = param.blocks_.begin();
      for ( ; iter != param.blocks_.end() && !ds_info.is_destroyed(); iter++)
      {
        CheckResult current;
        check_single_block(*iter, param.peer_id_, param.flag_, current);
        result.push_back(current);
        if (param.interval_ > 0)
        {
          interruptable_usleep(param.interval_ * 1000);
        }
      }
    }

    void CheckManager::check_single_block(const uint64_t block_id,
        const uint64_t peer_ip, const CheckFlag flag, CheckResult& result)
    {
      TIMER_START();
      IndexHeaderV2 main_header;
      vector<FileInfoV2> main_finfos;
      result.block_id_ = block_id;
      result.status_ = get_block_manager().traverse(main_header, main_finfos, block_id, block_id);
      if (TFS_SUCCESS == result.status_)
      {
        if (main_finfos.size() > 0)
        {
          SyncBase* sync_mirror = NULL;
          result.status_ = get_sync_mirror(peer_ip, sync_mirror);
          if (TFS_SUCCESS == result.status_)
          {
            result.status_ = check_single_block(block_id, main_finfos, *sync_mirror, flag, result);
          }
        }
        else if (main_finfos.size() == 0)
        {
          TBSYS_LOG(DEBUG, "ignore empty block, won't check");
          result.more_ = 0;
          result.diff_ = 0;
          result.less_ = 0;
        }
      }
      TIMER_END();

      if (TFS_SUCCESS != result.status_)
      {
        TBSYS_LOG(WARN, "check block %" PRI64_PREFIX "u fail, ret: %d", block_id, result.status_);
      }
      else
      {
        TBSYS_LOG(DEBUG, "check block %" PRI64_PREFIX "u success. "
            "count: %zd, more: %d, diff: %d, less: %d, cost: %" PRI64_PREFIX "d",
            block_id, main_finfos.size(), result.more_, result.diff_, result.less_,
            TIMER_DURATION());
      }
    }

    int CheckManager::check_single_block(const uint64_t block_id,
        vector<FileInfoV2>& finfos, SyncBase& peer, CheckFlag flag, CheckResult& result)
    {
      uint64_t peer_ns = Func::get_host_ip(peer.get_dest_addr().c_str());
      vector<uint64_t> replicas;
      IndexDataV2 peer_index;
      int ret = get_data_helper().get_block_replicas(peer_ns, block_id, replicas);
      if (TFS_SUCCESS == ret)
      {
        ret = (replicas.size() > 0) ? TFS_SUCCESS : EXIT_NO_DATASERVER;
      }
      else if (EXIT_NO_BLOCK == ret || EXIT_BLOCK_NOT_FOUND == ret)
      {
        // less block in slave cluster will auto synced
        if (flag & CHECK_FLAG_SYNC_LESS)
        {
          ret = TFS_SUCCESS;
        }
      }

      if (TFS_SUCCESS == ret)
      {
        vector<uint64_t>::iterator iter = replicas.begin();
        for ( ; iter != replicas.end(); iter++)
        {
          ret = get_data_helper().read_index(*iter, block_id, block_id, peer_index);
          if (TFS_SUCCESS == ret)
          {
            break;
          }
        }
      }
      else
      {
        TBSYS_LOG(WARN, "read block %" PRI64_PREFIX "u index fail, peer ns: %s, ret: %d",
            block_id, tbsys::CNetUtil::addrToString(peer_ns).c_str(), ret);
      }

      if (TFS_SUCCESS == ret)
      {
        vector<FileInfoV2> more;
        vector<FileInfoV2> diff;
        vector<FileInfoV2> less;
        compare_block_fileinfos(block_id, finfos, peer_index.finfos_, more, diff, less);

        // if CHECK_FLAG_SYNC not set, just compare, don't sync
        if (flag & CHECK_FLAG_SYNC)
        {
          ret = process_more_files(peer, block_id, more);
          if (TFS_SUCCESS == ret)
          {
            ret = process_diff_files(peer, block_id, diff);
          }
          if (TFS_SUCCESS == ret)
          {
            ret = process_less_files(peer, block_id, less);
          }
        }

        if (TFS_SUCCESS == ret)
        {
          result.more_ = more.size();
          result.diff_ = diff.size();
          result.less_ = less.size();
        }
      }

      return ret;
    }

    int CheckManager::process_more_files(SyncBase& peer,
        const uint64_t block_id, const vector<FileInfoV2>& more)
    {
      int ret = TFS_SUCCESS;
      vector<FileInfoV2>::const_iterator iter = more.begin();
      for ( ; (TFS_SUCCESS == ret) && (iter != more.end()); iter++)
      {
        ret = peer.write_sync_log(OPLOG_INSERT, block_id, iter->id_);
        TBSYS_LOG(DEBUG, "MORE file compared with %s blockid %" PRI64_PREFIX "u fileid %" PRI64_PREFIX "u",
            peer.get_dest_addr().c_str(), block_id, iter->id_);
      }
      return ret;
    }

    int CheckManager::process_diff_files(SyncBase& peer,
        const uint64_t block_id, const vector<FileInfoV2>& diff)
    {
      int ret = TFS_SUCCESS;
      vector<FileInfoV2>::const_iterator iter = diff.begin();
      for ( ; (TFS_SUCCESS == ret) && (iter != diff.end()); iter++)
      {
        ret = peer.write_sync_log(OPLOG_REMOVE, block_id, iter->id_);
        TBSYS_LOG(DEBUG, "DIFF file compared with %s blockid %" PRI64_PREFIX "u fileid %" PRI64_PREFIX "u",
            peer.get_dest_addr().c_str(), block_id, iter->id_);
      }
      return ret;
    }

    int CheckManager::process_less_files(SyncBase& peer,
        const uint64_t block_id, const vector<FileInfoV2>& less)
    {
      vector<FileInfoV2>::const_iterator iter = less.begin();
      for ( ; iter != less.end(); iter++)
      {
        // TODO: process less file in master cluster
        TBSYS_LOG(DEBUG, "LESS file compared with %s blockid %" PRI64_PREFIX "u fileid %" PRI64_PREFIX "u",
            peer.get_dest_addr().c_str(), block_id, iter->id_);
      }
      return TFS_SUCCESS;
    }

    void CheckManager::compare_block_fileinfos(const uint64_t block_id,
        const vector<FileInfoV2>& left,
        const vector<FileInfoV2>& right, vector<FileInfoV2>& more,
        vector<FileInfoV2>& diff, vector<FileInfoV2>& less)
    {
      // transform right vector to set for fast search
      set<FileInfoV2, FileInfoCompare> files;
      vector<FileInfoV2>::const_iterator iter = right.begin();
      for ( ; iter != right.end(); iter++)
      {
        files.insert(*iter);
      }

      iter = left.begin();
      for ( ; iter != left.end(); iter++)
      {
        // deleted or invalid, ignore
        if (iter->status_ & FILE_STATUS_DELETE)
        {
          TBSYS_LOG(DEBUG, "blockid: %" PRI64_PREFIX "u, fileid: %" PRI64_PREFIX "u has been deleted.",
              block_id, iter->id_);
          files.erase(*iter);
          continue;
        }

        set<FileInfoV2, FileInfoCompare>::iterator sit = files.find(*iter);
        if (sit == files.end()) // not found
        {
          more.push_back(*iter);
        }
        else
        {
          // size or crc diff, sync file data to peer
          if ((iter->size_ != sit->size_) || (iter->crc_ != sit->crc_))
          {
            more.push_back(*iter);
          }
          else if (iter->status_ != sit->status_) // file in diff status, do remove
          {
            diff.push_back(*iter);
          }
          files.erase(sit);
        }
      }

      set<FileInfoV2, FileInfoCompare>::iterator it = files.begin();
      for ( ; it != files.end(); it++)
      {
        if (!(it->status_ & FILE_STATUS_DELETE))
        {
          less.push_back(*it);
        }
      }
    }

  }
}
